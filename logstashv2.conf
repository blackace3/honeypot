# ===============================
# Input section
# ===============================
input {

  # Fatt                                 
  file { path => ["/data/fatt/log/fatt.log"] codec => json type => "Fatt" }  

  # Suricata
  file { path => ["/data/suricata/log/eve.json"] codec => json type => "Suricata" }

  # P0f
  file { path => ["/data/p0f/log/p0f.json"] codec => json type => "P0f" }

  # Adbhoney
  file { path => ["/data/adbhoney/log/adbhoney.json"] codec => json type => "Adbhoney" }

  # Beelzebub
  file { path => ["/data/beelzebub/log/beelzebub.json"] codec => json type => "Beelzebub" }

  # Ciscoasa
  file { path => ["/data/ciscoasa/log/ciscoasa.log"] codec => plain type => "Ciscoasa" }

  # CitrixHoneypot
  file { path => ["/data/citrixhoneypot/log/server.log"] codec => json type => "CitrixHoneypot" }

  # Conpot
  file { path => ["/data/conpot/log/*.json"] codec => json type => "ConPot" }

  # Cowrie
  file { path => ["/data/cowrie/log/cowrie.json"] codec => json type => "Cowrie" }

  # Dionaea
  file { path => ["/data/dionaea/log/dionaea.json"] codec => json type => "Dionaea" }

  # Dicompot
  file { path => ["/data/dicompot/log/dicompot.log"] codec => json type => "Dicompot" }

  # Ddospot
  file { path => ["/data/ddospot/log/*.log"] codec => json type => "Ddospot" }

  # ElasticPot
  file { path => ["/data/elasticpot/log/elasticpot.json"] codec => json type => "ElasticPot" }

  # Endlessh
  file { path => ["/data/endlessh/log/endlessh.log"] codec => plain type => "Endlessh" }

  # Galah
  file { path => ["/data/galah/log/galah.json"] codec => json type => "Galah" }

  # Glutton
  file { path => ["/data/glutton/log/glutton.log"] codec => json type => "Glutton" }

  # Go-pot
  file { path => ["/data/go-pot/log/go-pot.json"] codec => json type => "Go-pot" }

  # H0neytr4p
  file { path => ["/data/h0neytr4p/log/log.json"] codec => json type => "H0neytr4p" }

  # Hellpot
  file { path => ["/data/hellpot/log/hellpot.log"] codec => json type => "Hellpot" }

  # Heralding
  file { path => ["/data/heralding/log/auth.csv"] type => "Heralding" }

  # Honeyaml
  file { path => ["/data/honeyaml/log/honeyaml.log"] codec => json type => "Honeyaml" }

  # Honeypots
  file { path => ["/data/honeypots/log/*.log"] codec => json type => "Honeypots" }

  # Honeytrap
  file { path => ["/data/honeytrap/log/attackers.json"] codec => json type => "Honeytrap" }

  # Ipphoney
  file { path => ["/data/ipphoney/log/ipphoney.json"] codec => json type => "Ipphoney" }

  # Log4pot
  file { path => ["/data/log4pot/log/log4pot.log"] codec => json type => "Log4pot" }

  # Mailoney
  file { path => ["/data/mailoney/log/commands.log"] codec => json type => "Mailoney" }

  # Medpot
  file { path => ["/data/medpot/log/medpot.log"] codec => json type => "Medpot" }

  # Miniprint
  file { path => ["/data/miniprint/log/miniprint.json"] codec => json type => "Miniprint" }

  # Redishoneypot
  file { path => ["/data/redishoneypot/log/redishoneypot.log"] codec => json type => "Redishoneypot" }

  # Sentrypeer 
  file { path => ["/data/sentrypeer/log/sentrypeer.json"] codec => json type => "Sentrypeer" }

  # Host NGINX
  file { path => ["/data/nginx/log/access.log"] codec => json type => "NGINX" }

  # Tanner
  file { path => ["/data/tanner/log/tanner_report.json"] codec => json type => "Tanner" }

  # Wordpot
  file { path => ["/data/wordpot/log/wordpot.log"] codec => json type => "Wordpot" }

}

# ===============================
# Filter section
# ===============================
filter {

  # --------------------------
  # Fixed filters...
  # --------------------------

  # CitrixHoneypot (fixed)
  if [type] == "CitrixHoneypot" {
    grok {
      match => {
        "message" => [
          "\A\(%{IPV4:src_ip}:%{INT:src_port}\): %{JAVAMETHOD:http.http_method} %{CISCO_REASON:fileinfo.state}: %{UNIXPATH:fileinfo.filename}",
          "\A\(%{IPV4:src_ip}:%{INT:src_port}\): %{JAVAMETHOD:http.http_method} %{CISCO_REASON:fileinfo.state}: %{GREEDYDATA:payload}",
          "\A\(%{IPV4:src_ip}:%{INT:src_port}\): %{S3_REQUEST_LINE:msg} %{CISCO_REASON:fileinfo.state}: %{GREEDYDATA:payload}",
          "\A\(%{IPV4:src_ip}:%{INT:src_port}\): %{GREEDYDATA:msg}"
        ]
      }
    }
    date { match => [ "asctime", "ISO8601" ] remove_field => ["asctime", "message"] }
    mutate {
      add_field => { "dest_port" => "443" }
      rename => { "levelname" => "level" }
    }
  }

  # Endlessh (fixed)
  if [type] == "Endlessh" {
    grok {
      match => {
        "message" => [
          "\A%{TIMESTAMP_ISO8601:timestamp} %{WORD:reason} host=%{IPV4:src_ip} port=%{INT:src_port} fd=%{INT} time=%{NUMBER:duration} bytes=%{NUMBER:bytes}",
          "\A%{TIMESTAMP_ISO8601:timestamp} %{WORD:reason} host=%{IPV4:src_ip} port=%{INT:src_port} fd=%{INT} n=%{INT}/%{INT}"
        ]
      }
    }
    date { match => [ "timestamp", "ISO8601" ] remove_field => ["timestamp"] }
    mutate {
      add_field => {
        "dest_port" => "22"
        "dest_ip" => "$(hostname -I | awk '{print $1}')"
      }
    }
  }

  # Heralding (fixed)
  if [type] == "Heralding" {
    csv {
      columns => ["timestamp","auth_id","session_id","src_ip","src_port","dest_ip","dest_port","proto","username","password"]
      separator => ","
    }
    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSSSSS" ]
      remove_field => ["timestamp"]
    }
  }

  # Redishoneypot (fixed)
  if [type] == "Redishoneypot" {
    date {
      match => [ "time", "yyyy-MM-dd HH:mm:ss" ]
      remove_field => ["time", "timestamp"]
    }
    mutate {
      split => ["addr", ":"]
      add_field => {
        "src_ip" => "%{[addr][0]}"
        "src_port" => "%{[addr][1]}"
        "dest_port" => "6379"
        "dest_ip" => "$(hostname -I | awk '{print $1}')"
      }
      remove_field => ["addr"]
    }
  }

  # Drop broken events
  if "_grokparsefailure" in [tags] { drop {} }
  if "_jsonparsefailure" in [tags] { drop {} }

  # Add host metadata
  mutate {
    add_field => {
      "t-pot_ip_ext" => "$(hostname -I | awk '{print $1}')"
      "t-pot_ip_int" => "${MY_INTIP}"
      "t-pot_hostname" => "${MY_HOSTNAME}"
    }
  }

  # GeoIP lookups
  if [src_ip] {
    geoip { source => "src_ip" }
    geoip { source => "src_ip" target => "geoip_asn" default_database_type => "ASN" }
  }

}

# ===============================
# Output Section
# ===============================
output {

  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "honeypot-%{+YYYY.MM.dd}"
    ssl => true
    ssl_certificate_verification => false
    user => ""
    password => ""
    template => "/etc/logstash/template.json"
    template_overwrite => true
  }

  file {
    path => "/var/log/logstash/honeypot-%{+YYYY-MM-dd}.log"
    codec => json_lines
  }

}
